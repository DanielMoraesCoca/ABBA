// backend/src/agents/deployer.js
const fs = require('fs').promises;
const path = require('path');

class DeployerAgent {
  constructor() {
    this.name = 'Deployer';
    this.deploymentPath = path.join(__dirname, '../../deployments');
    this.initializeDeploymentDirectory();
  }

  async initializeDeploymentDirectory() {
    try {
      await fs.mkdir(this.deploymentPath, { recursive: true });
    } catch (error) {
      console.error('Failed to create deployment directory:', error);
    }
  }

  async deployAgent(agentName, agentCode, deploymentType = 'docker') {
    console.log(`DEPLOYER: Starting deployment of ${agentName}...`);
    
    const deploymentId = `${agentName}-${Date.now()}`;
    const agentPath = path.join(this.deploymentPath, deploymentId);
    
    await fs.mkdir(agentPath, { recursive: true });

    // Save agent code
    await fs.writeFile(
      path.join(agentPath, `${agentName.toLowerCase()}.js`),
      agentCode
    );

    // Generate deployment files based on type
    let deploymentFiles;
    switch (deploymentType) {
      case 'docker':
        deploymentFiles = await this.generateDockerDeployment(agentName, agentPath);
        break;
      case 'serverless':
        deploymentFiles = await this.generateServerlessDeployment(agentName, agentPath);
        break;
      case 'kubernetes':
        deploymentFiles = await this.generateKubernetesDeployment(agentName, agentPath);
        break;
      default:
        deploymentFiles = await this.generateDockerDeployment(agentName, agentPath);
    }

    console.log(`DEPLOYER: Generated ${deploymentFiles.length} deployment files`);
    
    return {
      deploymentId,
      path: agentPath,
      files: deploymentFiles,
      status: 'ready',
      instructions: this.getDeploymentInstructions(deploymentType, agentName)
    };
  }

  async generateDockerDeployment(agentName, agentPath) {
    const files = [];

    // Dockerfile
    const dockerfile = `
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy agent code
COPY . .

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001
USER nodejs

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD node healthcheck.js || exit 1

# Start agent
CMD ["node", "${agentName.toLowerCase()}.js"]
`;

    await fs.writeFile(path.join(agentPath, 'Dockerfile'), dockerfile);
    files.push('Dockerfile');

    // docker-compose.yml
    const dockerCompose = `
version: '3.8'

services:
  ${agentName.toLowerCase()}:
    build: .
    container_name: ${agentName.toLowerCase()}-agent
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - AGENT_NAME=${agentName}
      - LOG_LEVEL=info
    volumes:
      - ./logs:/app/logs
      - ./data:/app/data
    networks:
      - agent-network
    mem_limit: 512m
    cpus: '0.5'

networks:
  agent-network:
    driver: bridge

volumes:
  logs:
  data:
`;

    await fs.writeFile(path.join(agentPath, 'docker-compose.yml'), dockerCompose);
    files.push('docker-compose.yml');

    // .dockerignore
    const dockerignore = `
node_modules
npm-debug.log
.env
.git
.gitignore
README.md
.DS_Store
coverage
.nyc_output
`;

    await fs.writeFile(path.join(agentPath, '.dockerignore'), dockerignore);
    files.push('.dockerignore');

    // package.json
    const packageJson = {
      name: agentName.toLowerCase(),
      version: '1.0.0',
      description: `${agentName} Agent - Generated by ABBA`,
      main: `${agentName.toLowerCase()}.js`,
      scripts: {
        start: `node ${agentName.toLowerCase()}.js`,
        test: 'jest',
        'docker:build': `docker build -t ${agentName.toLowerCase()}-agent .`,
        'docker:run': `docker run -d -p 3000:3000 ${agentName.toLowerCase()}-agent`,
        'docker:stop': `docker stop ${agentName.toLowerCase()}-agent`
      },
      dependencies: {
        express: '^4.18.2',
        dotenv: '^16.0.3',
        winston: '^3.8.2'
      },
      devDependencies: {
        jest: '^29.5.0'
      },
      engines: {
        node: '>=18.0.0'
      }
    };

    await fs.writeFile(
      path.join(agentPath, 'package.json'),
      JSON.stringify(packageJson, null, 2)
    );
    files.push('package.json');

    // Environment file template
    const envTemplate = `
# ${agentName} Agent Configuration
NODE_ENV=production
PORT=3000
AGENT_NAME=${agentName}
LOG_LEVEL=info

# API Keys (add your keys here)
# OPENAI_API_KEY=
# DATABASE_URL=

# Resource Limits
MAX_MEMORY_MB=512
MAX_CPU_PERCENT=50
REQUEST_TIMEOUT_MS=30000
`;

    await fs.writeFile(path.join(agentPath, '.env.example'), envTemplate);
    files.push('.env.example');

    // Health check script
    const healthcheck = `
const http = require('http');

const options = {
  host: 'localhost',
  port: 3000,
  path: '/health',
  timeout: 2000
};

const request = http.request(options, (res) => {
  process.exit(res.statusCode === 200 ? 0 : 1);
});

request.on('error', () => {
  process.exit(1);
});

request.end();
`;

    await fs.writeFile(path.join(agentPath, 'healthcheck.js'), healthcheck);
    files.push('healthcheck.js');

    // Deployment script
    const deployScript = `#!/bin/bash

echo "Deploying ${agentName} Agent..."

# Build Docker image
echo "Building Docker image..."
docker build -t ${agentName.toLowerCase()}-agent .

# Stop existing container if running
echo "Stopping existing container..."
docker stop ${agentName.toLowerCase()}-agent 2>/dev/null || true
docker rm ${agentName.toLowerCase()}-agent 2>/dev/null || true

# Run new container
echo "Starting new container..."
docker-compose up -d

# Wait for health check
echo "Waiting for agent to be healthy..."
sleep 5

# Check status
if docker ps | grep -q ${agentName.toLowerCase()}-agent; then
  echo "${agentName} Agent deployed successfully!"
  echo "Access at: http://localhost:3000"
else
  echo "Deployment failed. Check logs: docker logs ${agentName.toLowerCase()}-agent"
  exit 1
fi
`;

    await fs.writeFile(path.join(agentPath, 'deploy.sh'), deployScript);
    await fs.chmod(path.join(agentPath, 'deploy.sh'), '755');
    files.push('deploy.sh');

    return files;
  }

  async generateServerlessDeployment(agentName, agentPath) {
    const files = [];

    // serverless.yml for AWS Lambda
    const serverlessConfig = `
service: ${agentName.toLowerCase()}-agent

provider:
  name: aws
  runtime: nodejs18.x
  stage: \${opt:stage, 'dev'}
  region: \${opt:region, 'us-east-1'}
  memorySize: 512
  timeout: 30

functions:
  ${agentName.toLowerCase()}:
    handler: handler.main
    events:
      - http:
          path: /
          method: ANY
      - http:
          path: /{proxy+}
          method: ANY
    environment:
      AGENT_NAME: ${agentName}
      NODE_ENV: production

plugins:
  - serverless-offline
  - serverless-plugin-optimize

package:
  exclude:
    - .git/**
    - .gitignore
    - .DS_Store
    - npm-debug.log
    - .serverless/**
    - tests/**
`;

    await fs.writeFile(path.join(agentPath, 'serverless.yml'), serverlessConfig);
    files.push('serverless.yml');

    // Lambda handler
    const handler = `
const serverless = require('serverless-http');
const express = require('express');
const ${agentName} = require('./${agentName.toLowerCase()}');

const app = express();
app.use(express.json());

const agent = new ${agentName}();

app.post('/execute', async (req, res) => {
  try {
    const result = await agent.process(req.body);
    res.json({ success: true, result });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

app.get('/health', (req, res) => {
  res.json({ status: 'healthy', agent: '${agentName}' });
});

module.exports.main = serverless(app);
`;

    await fs.writeFile(path.join(agentPath, 'handler.js'), handler);
    files.push('handler.js');

    return files;
  }

  async generateKubernetesDeployment(agentName, agentPath) {
    const files = [];

    // Kubernetes deployment
    const k8sDeployment = `
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${agentName.toLowerCase()}-agent
  labels:
    app: ${agentName.toLowerCase()}-agent
spec:
  replicas: 2
  selector:
    matchLabels:
      app: ${agentName.toLowerCase()}-agent
  template:
    metadata:
      labels:
        app: ${agentName.toLowerCase()}-agent
    spec:
      containers:
      - name: ${agentName.toLowerCase()}
        image: ${agentName.toLowerCase()}-agent:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: AGENT_NAME
          value: "${agentName}"
        resources:
          limits:
            memory: "512Mi"
            cpu: "500m"
          requests:
            memory: "256Mi"
            cpu: "250m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: ${agentName.toLowerCase()}-agent-service
spec:
  selector:
    app: ${agentName.toLowerCase()}-agent
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
  type: LoadBalancer
`;

    await fs.writeFile(path.join(agentPath, 'k8s-deployment.yaml'), k8sDeployment);
    files.push('k8s-deployment.yaml');

    return files;
  }

  getDeploymentInstructions(type, agentName) {
    const instructions = {
      docker: `
# Docker Deployment Instructions for ${agentName}

1. Navigate to deployment directory:
   cd deployments/${agentName}-*/

2. Build and run with Docker Compose:
   docker-compose up -d

OR use the deployment script:
   ./deploy.sh

3. Access the agent:
   http://localhost:3000

4. View logs:
   docker logs ${agentName.toLowerCase()}-agent

5. Stop the agent:
   docker-compose down
`,
      serverless: `
# Serverless Deployment Instructions for ${agentName}

1. Install Serverless Framework:
   npm install -g serverless

2. Navigate to deployment directory:
   cd deployments/${agentName}-*/

3. Install dependencies:
   npm install

4. Deploy to AWS:
   serverless deploy

5. Test locally:
   serverless offline start

6. View logs:
   serverless logs -f ${agentName.toLowerCase()}
`,
      kubernetes: `
# Kubernetes Deployment Instructions for ${agentName}

1. Build Docker image:
   docker build -t ${agentName.toLowerCase()}-agent:latest .

2. Apply Kubernetes configuration:
   kubectl apply -f k8s-deployment.yaml

3. Check deployment status:
   kubectl get deployments
   kubectl get pods
   kubectl get services

4. View logs:
   kubectl logs -l app=${agentName.toLowerCase()}-agent

5. Scale deployment:
   kubectl scale deployment ${agentName.toLowerCase()}-agent --replicas=3

6. Delete deployment:
   kubectl delete -f k8s-deployment.yaml
`
    };

    return instructions[type] || instructions.docker;
  }
}

module.exports = DeployerAgent;