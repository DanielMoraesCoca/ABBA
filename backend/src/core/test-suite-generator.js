const fs = require('fs').promises;
const path = require('path');
const TestWriterAgent = require('../agents/testwriter');

class TestSuiteGenerator {
    constructor() {
        this.testWriter = new TestWriterAgent();
        this.testDir = path.join(__dirname, '../../tests');
        this.coverageTargets = {
            unit: 80,
            integration: 70,
            e2e: 60
        };
    }

    async initialize() {
        // Create test directories
        const dirs = [
            'tests/unit/agents',
            'tests/unit/core',
            'tests/integration',
            'tests/performance',
            'tests/e2e',
            'tests/load'
        ];

        for (const dir of dirs) {
            await fs.mkdir(path.join(__dirname, '../../', dir), { recursive: true });
        }
    }

    async generateAllTests() {
        console.log('Generating Complete Test Suite...\n');
        
        const results = {
            unit: [],
            integration: [],
            performance: [],
            load: [],
            total: 0,
            generated: 0,
            failed: 0
        };

        // Generate unit tests for each agent
        console.log('Generating Unit Tests for Agents...');
        const agents = [
            'orchestrator', 'interpreter', 'architect', 'coder',
            'validator', 'testwriter', 'monitor', 'deployer', 'code-reviewer'
        ];

        for (const agentName of agents) {
            try {
                const testCode = await this.generateAgentUnitTest(agentName);
                const testPath = path.join(this.testDir, 'unit/agents', `${agentName}.test.js`);
                await fs.writeFile(testPath, testCode);
                results.unit.push(agentName);
                results.generated++;
                console.log(`   ${agentName}.test.js generated`);
            } catch (error) {
                console.log(`   Failed to generate test for ${agentName}:`, error.message);
                results.failed++;
            }
        }

        // Generate integration tests
        console.log('\ Generating Integration Tests...');
        const integrationTests = await this.generateIntegrationTests();
        results.integration = integrationTests;
        results.generated += integrationTests.length;

        // Generate performance tests
        console.log('\n Generating Performance Tests...');
        const performanceTests = await this.generatePerformanceTests();
        results.performance = performanceTests;
        results.generated += performanceTests.length;

        // Generate load tests
        console.log('\n Generating Load Tests...');
        const loadTests = await this.generateLoadTests();
        results.load = loadTests;
        results.generated += loadTests.length;

        results.total = results.generated + results.failed;

        return results;
    }

    async generateAgentUnitTest(agentName) {
        const agentPath = path.join(__dirname, '../agents', agentName + '.js');
        
        try {
            const agentCode = await fs.readFile(agentPath, 'utf-8');
            
            // Use TestWriter to generate test
            const testRequest = {
                code: agentCode,
                agentName,
                testType: 'unit',
                coverage: this.coverageTargets.unit
            };

            const generatedTest = await this.testWriter.generateTestForCode(testRequest);
            
            // Add custom test structure
            return `/**
 * Unit Tests for ${agentName.charAt(0).toUpperCase() + agentName.slice(1)} Agent
 * Generated by ABBA TestWriter Agent
 * Coverage Target: ${this.coverageTargets.unit}%
 */

const { describe, it, expect, beforeEach, afterEach } = require('@jest/globals');
const ${agentName.charAt(0).toUpperCase() + agentName.slice(1)}Agent = require('../../../src/agents/${agentName}');

describe('${agentName.charAt(0).toUpperCase() + agentName.slice(1)} Agent', () => {
    let agent;
    
    beforeEach(() => {
        agent = new ${agentName.charAt(0).toUpperCase() + agentName.slice(1)}Agent();
    });
    
    afterEach(() => {
        // Cleanup
        agent = null;
    });
    
    describe('Initialization', () => {
        it('should initialize with correct name and role', () => {
            expect(agent.name).toBeDefined();
            expect(agent.role).toBeDefined();
            expect(typeof agent.process).toBe('function');
        });
    });
    
    describe('Core Functionality', () => {
        ${generatedTest || this.generateDefaultTests(agentName)}
    });
    
    describe('Error Handling', () => {
        it('should handle invalid input gracefully', async () => {
            const result = await agent.process(null);
            expect(result.error).toBeDefined();
        });
        
        it('should handle empty input', async () => {
            const result = await agent.process('');
            expect(result).toBeDefined();
        });
    });
    
    describe('Performance', () => {
        it('should process within acceptable time limit', async () => {
            const startTime = Date.now();
            await agent.process('Test input');
            const duration = Date.now() - startTime;
            expect(duration).toBeLessThan(5000); // 5 seconds max
        });
    });
});`;
        } catch (error) {
            // Fallback test template
            return this.generateFallbackTest(agentName);
        }
    }

    generateDefaultTests(agentName) {
        return `
        it('should process valid input successfully', async () => {
            const input = 'Test input for ${agentName}';
            const result = await agent.process(input);
            expect(result).toBeDefined();
            expect(result.success).toBe(true);
        });
        
        it('should maintain context between calls', async () => {
            const input1 = 'First input';
            const input2 = 'Second input';
            
            await agent.process(input1);
            const result = await agent.process(input2);
            
            expect(result).toBeDefined();
        });`;
    }

    generateFallbackTest(agentName) {
        return `/**
 * Unit Tests for ${agentName} Agent
 * Fallback template - customize as needed
 */

const { describe, it, expect } = require('@jest/globals');

describe('${agentName} Agent', () => {
    it('should be implemented', () => {
        expect(true).toBe(true);
    });
});`;
    }

    async generateIntegrationTests() {
        const tests = [];
        
        // Pipeline integration test
        const pipelineTest = `/**
 * Integration Test - Agent Pipeline
 * Tests the complete flow from description to code generation
 */

const { describe, it, expect, beforeAll, afterAll } = require('@jest/globals');
const OrchestratorAgent = require('../../src/agents/orchestrator');
const MCPServer = require('../../src/core/mcp-server');

describe('Agent Pipeline Integration', () => {
    let mcp;
    let orchestrator;
    
    beforeAll(() => {
        mcp = new MCPServer();
        orchestrator = new OrchestratorAgent(mcp);
    });
    
    afterAll(() => {
        // Cleanup
    });
    
    it('should process description through complete pipeline', async () => {
        const description = 'Create a simple calculator agent';
        
        const result = await orchestrator.processDescription(description);
        
        expect(result).toBeDefined();
        expect(result.interpretation).toBeDefined();
        expect(result.architecture).toBeDefined();
        expect(result.generatedCode).toBeDefined();
        expect(result.validation).toBeDefined();
    }, 30000); // 30 second timeout
    
    it('should handle complex descriptions', async () => {
        const description = 'Create an agent that monitors system health, sends alerts via email, and generates daily reports';
        
        const result = await orchestrator.processDescription(description);
        
        expect(result.success).toBe(true);
        expect(result.generatedCode).toContain('class');
    }, 30000);
    
    it('should validate generated code', async () => {
        const description = 'Create a data processing agent';
        
        const result = await orchestrator.processDescription(description);
        
        expect(result.validation).toBeDefined();
        expect(result.validation.syntaxValid).toBe(true);
        expect(result.validation.hasErrors).toBe(false);
    }, 30000);
});`;

        await fs.writeFile(
            path.join(this.testDir, 'integration/pipeline.test.js'),
            pipelineTest
        );
        tests.push('pipeline.test.js');

        // API integration test
        const apiTest = `/**
 * Integration Test - API Endpoints
 * Tests all API endpoints and their interactions
 */

const request = require('supertest');
const { app } = require('../../src/index');

describe('API Integration Tests', () => {
    describe('POST /api/create-agent', () => {
        it('should create agent from description', async () => {
            const response = await request(app)
                .post('/api/create-agent')
                .send({ description: 'Test agent' })
                .expect(200);
            
            expect(response.body.success).toBe(true);
            expect(response.body.agent).toBeDefined();
        });
    });
    
    describe('GET /api/health', () => {
        it('should return system health', async () => {
            const response = await request(app)
                .get('/api/health')
                .expect(200);
            
            expect(response.body.status).toBe('ok');
        });
    });
    
    describe('WebSocket Integration', () => {
        it('should establish WebSocket connection', (done) => {
            const WebSocket = require('ws');
            const ws = new WebSocket('ws://localhost:3333');
            
            ws.on('open', () => {
                expect(ws.readyState).toBe(WebSocket.OPEN);
                ws.close();
                done();
            });
        });
    });
});`;

        await fs.writeFile(
            path.join(this.testDir, 'integration/api.test.js'),
            apiTest
        );
        tests.push('api.test.js');

        return tests;
    }

    async generatePerformanceTests() {
        const tests = [];
        
        const performanceTest = `/**
 * Performance Benchmark Tests
 * Measures system performance metrics
 */

class PerformanceBenchmark {
    constructor() {
        this.results = [];
        this.thresholds = {
            agentCreation: 5000, // 5 seconds
            toolExecution: 500,  // 500ms
            apiResponse: 200,    // 200ms
            widgetLoad: 1000     // 1 second
        };
    }
    
    async runAllBenchmarks() {
        console.log(' Running Performance Benchmarks\\n');
        
        await this.benchmarkAgentCreation();
        await this.benchmarkToolExecution();
        await this.benchmarkAPIResponse();
        await this.benchmarkMemoryUsage();
        
        return this.generateReport();
    }
    
    async benchmarkAgentCreation() {
        const OrchestratorAgent = require('../../src/agents/orchestrator');
        const orchestrator = new OrchestratorAgent();
        
        const descriptions = [
            'Simple calculator agent',
            'Complex data processing agent with multiple features',
            'Real-time monitoring agent with alerts'
        ];
        
        const times = [];
        
        for (const desc of descriptions) {
            const start = Date.now();
            await orchestrator.processDescription(desc);
            const duration = Date.now() - start;
            times.push(duration);
        }
        
        const avg = times.reduce((a, b) => a + b, 0) / times.length;
        
        this.results.push({
            name: 'Agent Creation',
            average: avg,
            max: Math.max(...times),
            min: Math.min(...times),
            passed: avg < this.thresholds.agentCreation
        });
    }
    
    async benchmarkToolExecution() {
        const ToolRegistry = require('../../src/core/tool-registry');
        const registry = new ToolRegistry();
        
        const iterations = 100;
        const times = [];
        
        for (let i = 0; i < iterations; i++) {
            const start = Date.now();
            await registry.execute('http_request', {
                url: 'https://api.github.com',
                method: 'GET'
            });
            times.push(Date.now() - start);
        }
        
        const avg = times.reduce((a, b) => a + b, 0) / times.length;
        
        this.results.push({
            name: 'Tool Execution',
            average: avg,
            max: Math.max(...times),
            min: Math.min(...times),
            passed: avg < this.thresholds.toolExecution
        });
    }
    
    async benchmarkAPIResponse() {
        const fetch = (await import('node-fetch')).default;
        const times = [];
        
        for (let i = 0; i < 50; i++) {
            const start = Date.now();
            await fetch('http://localhost:3333/api/health');
            times.push(Date.now() - start);
        }
        
        const avg = times.reduce((a, b) => a + b, 0) / times.length;
        
        this.results.push({
            name: 'API Response Time',
            average: avg,
            max: Math.max(...times),
            min: Math.min(...times),
            passed: avg < this.thresholds.apiResponse
        });
    }
    
    async benchmarkMemoryUsage() {
        const initial = process.memoryUsage();
        
        // Simulate load
        const agents = [];
        for (let i = 0; i < 10; i++) {
            const OrchestratorAgent = require('../../src/agents/orchestrator');
            agents.push(new OrchestratorAgent());
        }
        
        const final = process.memoryUsage();
        const heapUsed = (final.heapUsed - initial.heapUsed) / 1024 / 1024; // MB
        
        this.results.push({
            name: 'Memory Usage (10 agents)',
            value: heapUsed.toFixed(2) + ' MB',
            passed: heapUsed < 100 // Less than 100MB for 10 agents
        });
    }
    
    generateReport() {
        console.log('\\n Performance Report:\\n');
        console.log('='.repeat(50));
        
        for (const result of this.results) {
            const status = result.passed ? '✅' : '❌';
            console.log(\`\${status} \${result.name}\`);
            if (result.average) {
                console.log(\`   Average: \${result.average.toFixed(2)}ms\`);
                console.log(\`   Min: \${result.min}ms | Max: \${result.max}ms\`);
            } else {
                console.log(\`   Value: \${result.value}\`);
            }
        }
        
        const passed = this.results.filter(r => r.passed).length;
        const total = this.results.length;
        
        console.log('\\n' + '='.repeat(50));
        console.log(\`Overall: \${passed}/\${total} benchmarks passed\`);
        
        return {
            passed,
            total,
            results: this.results
        };
    }
}

module.exports = PerformanceBenchmark;`;

        await fs.writeFile(
            path.join(this.testDir, 'performance/benchmark.js'),
            performanceTest
        );
        tests.push('benchmark.js');

        return tests;
    }

    async generateLoadTests() {
        const tests = [];
        
        const loadTest = `/**
 * Load Testing Suite
 * Tests system under heavy load
 */

class LoadTester {
    constructor() {
        this.results = {
            concurrent: 0,
            successful: 0,
            failed: 0,
            avgResponseTime: 0,
            maxResponseTime: 0,
            minResponseTime: Infinity,
            throughput: 0
        };
    }
    
    async runLoadTests() {
        console.log(' Starting Load Tests\\n');
        
        await this.testConcurrentAgentCreation(10);
        await this.testConcurrentAgentCreation(50);
        await this.testConcurrentAgentCreation(100);
        
        await this.testWebSocketConnections(100);
        await this.testAPIEndpointLoad(1000);
        
        return this.generateReport();
    }
    
    async testConcurrentAgentCreation(count) {
        console.log(\`Testing \${count} concurrent agent creations...\`);
        
        const fetch = (await import('node-fetch')).default;
        const promises = [];
        const times = [];
        
        for (let i = 0; i < count; i++) {
            const promise = (async () => {
                const start = Date.now();
                try {
                    const response = await fetch('http://localhost:3333/api/create-agent', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            description: \`Test agent \${i}\`
                        })
                    });
                    
                    if (response.ok) {
                        this.results.successful++;
                    } else {
                        this.results.failed++;
                    }
                    
                    const duration = Date.now() - start;
                    times.push(duration);
                    
                } catch (error) {
                    this.results.failed++;
                }
            })();
            
            promises.push(promise);
        }
        
        const startTime = Date.now();
        await Promise.all(promises);
        const totalTime = Date.now() - startTime;
        
        this.results.concurrent = Math.max(this.results.concurrent, count);
        this.results.avgResponseTime = times.reduce((a, b) => a + b, 0) / times.length;
        this.results.maxResponseTime = Math.max(...times, this.results.maxResponseTime);
        this.results.minResponseTime = Math.min(...times, this.results.minResponseTime);
        this.results.throughput = (count / totalTime) * 1000; // requests per second
        
        console.log(\`   Completed: \${this.results.successful}/\${count} successful\`);
        console.log(\`   Avg response time: \${this.results.avgResponseTime.toFixed(2)}ms\`);
        console.log(\`   Throughput: \${this.results.throughput.toFixed(2)} req/s\\n\`);
    }
    
    async testWebSocketConnections(count) {
        console.log(\`Testing \${count} WebSocket connections...\`);
        
        const WebSocket = require('ws');
        const connections = [];
        let connected = 0;
        
        for (let i = 0; i < count; i++) {
            try {
                const ws = new WebSocket('ws://localhost:3333');
                
                ws.on('open', () => {
                    connected++;
                });
                
                connections.push(ws);
            } catch (error) {
                // Connection failed
            }
        }
        
        // Wait for connections
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        console.log(\`   Established: \${connected}/\${count} connections\\n\`);
        
        // Close all connections
        connections.forEach(ws => ws.close());
    }
    
    async testAPIEndpointLoad(requests) {
        console.log(\`Testing \${requests} API requests...\`);
        
        const fetch = (await import('node-fetch')).default;
        const endpoints = [
            '/api/health',
            '/api/test',
            '/api/metrics',
            '/api/agents'
        ];
        
        let completed = 0;
        const startTime = Date.now();
        
        const promises = [];
        for (let i = 0; i < requests; i++) {
            const endpoint = endpoints[i % endpoints.length];
            promises.push(
                fetch(\`http://localhost:3333\${endpoint}\`)
                    .then(() => completed++)
                    .catch(() => {})
            );
        }
        
        await Promise.all(promises);
        const duration = (Date.now() - startTime) / 1000; // seconds
        
        console.log(\`   Completed: \${completed}/\${requests} requests\`);
        console.log(\`   Rate: \${(completed / duration).toFixed(2)} req/s\\n\`);
    }
    
    generateReport() {
        console.log('\\n Load Test Report:\\n');
        console.log('='.repeat(50));
        
        console.log('Results:');
        console.log(\`  Max Concurrent: \${this.results.concurrent}\`);
        console.log(\`  Successful: \${this.results.successful}\`);
        console.log(\`  Failed: \${this.results.failed}\`);
        console.log(\`  Success Rate: \${((this.results.successful / (this.results.successful + this.results.failed)) * 100).toFixed(2)}%\`);
        console.log(\`  Avg Response Time: \${this.results.avgResponseTime.toFixed(2)}ms\`);
        console.log(\`  Min Response Time: \${this.results.minResponseTime}ms\`);
        console.log(\`  Max Response Time: \${this.results.maxResponseTime}ms\`);
        console.log(\`  Throughput: \${this.results.throughput.toFixed(2)} req/s\`);
        
        const grade = this.calculateGrade();
        console.log(\`\\nOverall Grade: \${grade}\`);
        
        return this.results;
    }
    
    calculateGrade() {
        const successRate = this.results.successful / (this.results.successful + this.results.failed);
        
        if (successRate > 0.95 && this.results.avgResponseTime < 1000) return 'A - Excellent';
        if (successRate > 0.90 && this.results.avgResponseTime < 2000) return 'B - Good';
        if (successRate > 0.80 && this.results.avgResponseTime < 5000) return 'C - Acceptable';
        if (successRate > 0.70) return 'D - Needs Improvement';
        return 'F - Critical Issues';
    }
}

module.exports = LoadTester;`;

        await fs.writeFile(
            path.join(this.testDir, 'load/load-test.js'),
            loadTest
        );
        tests.push('load-test.js');

        return tests;
    }
}

module.exports = TestSuiteGenerator;